
Do realizacji fuzji z algorytmu SVO oraz PTAM pozyskiwane s± informacje o pozycji kamery. Dziêki znanej pozycji pocz±tkowej $[x_0, y_0, z_0]$ kamery mo¿na obliczyæ przesuniêcie. Na tej podstawie wysy³ana jest wiadomo¶æ do sterownika o przesuniêciu, uzyskanym z algorytmu wizualnego. Pozycjê kamery nale¿y przekonwertowaæ na pozycjê quadrocoptera przez odpowiedni± macierz rotacji $R$. Kamera zamontowana jest w dolnej, centralnej czê¶ci quadrocoptera, skierowana jest w pionowo w dó³.
\begin{equation*}
Rot(Y,\alpha)=
\left[ \begin{array}{ccc}
\cos(\frac{\pi}{2}) & 0 & \sin(\frac{\pi}{2})\\
0 & 1 & 0\\
-\sin(\frac{\pi}{2}) & 0 & \cos(\frac{\pi}{2})
\end{array} \right]=
\left[ \begin{array}{ccc}
0 & 0 & 1\\
0 & 1 & 0\\
-1 & 0 & 0
\end{array} \right].
\end{equation*}
Wiadomo¶æ wysy³ana do sterownika jest umieszczana w topicu o typie \textit{geometry\_msg/Vector3}. Parametr $\delta$, który trzeba dobraæ podczas testu, bêdzie decydowa³ czy wyst±pi³o przesuniêcie, czy te¿ nie. Poni¿szy wydruk pokazuje funkcjê rosow± \textit{Callback}, która uzyskuje informacjê o pozycji kamery z topicu \texttt{/svo/points}, którego typ to \textit{visualizatio\_msgs/Marker}.
\begin{lstlisting}[language=C++, frame=single,tabsize=1, caption={Pobranie warto¶ci po³o¿enia kamery}] 
void chatterCallback(const visualization_msgs::
/Marker::ConstPtr& msg)
{
  t[0][0]=msg->-pose.position.z;
  t[0][1]=msg->pose.position.y;
  t[0][2]=msg->pose.position.x;
}
\end{lstlisting}
W taki sam sposób uzyskiwany jest pomiar pozycji kamery z algorytmu PTAM z topicu \texttt{/vslam/pose}. Wiadomo¶æ ta jest typu \textit{geometry\_msgs/PoseWithCovarianceStamped}.
\begin{lstlisting}[language=C++, frame=single,tabsize=1, caption={Cze¶æ fuzji wykorzystuj±ca wizualne algorytmy wykrywania przesuniêcia}] 
{
 geometry_msgs::Vector3 Msg;

 if(abs(0.5*t[0][0]+0.5*t[1][0]-x_0)>delta){
 	x_0=0.5*t[0][0]+0.5*t[0][1];
 	Msg.x=x_0;
 }
 if(abs(0.5*t[0][1]+0.5*t[1][1]-y_0)>delta){
 	y_0=0.5*t[0][1]+0.5*t[1][1];
  	Msg.y=y_0;
 }
 if(abs(0.5*t[0][2]+0.5*t[1][2]-z_0)>delta){
 	z_0=0.5*t[0][2]+0.5*t[1][2];
  	Msg.z=z_0;
 }
 
}
\end{lstlisting}
